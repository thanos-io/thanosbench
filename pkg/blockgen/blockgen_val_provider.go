package blockgen

import (
	"fmt"
	"math/rand"

	"github.com/prometheus/prometheus/tsdb/labels"
)

// ValProviderConfig configures the number of metrics per
// sampling interval to be generated by `ValProvider`.
// The number of metrics per interval will be (MetricCount x TargetCount).
type ValProviderConfig struct {
	// MetricCount is the number of metrics each target produces.
	MetricCount int

	// TargetCount is the number of simulated collection targets.
	TargetCount int
}

// NewValProvider creates new ValProvider with the supplied
// config and a fixed random seed. Every instance of ValProvider
// will generate same metrics.
//
// TODO(ppanyukov): do we want to surface randSeed via config?
func NewValProvider(config ValProviderConfig) ValProvider {
	// seed rand with fixed value to get consistent repeatable results :)
	return &valProvider{
		config: config,
		random: rand.New(rand.NewSource(454)),
	}
}

// valProvider is implementation of `ValProvider`.
type valProvider struct {
	config ValProviderConfig
	random *rand.Rand
}

// Next implements ValProvider interface.
func (g *valProvider) Next() <-chan Val {
	c := make(chan Val)

	go func() {
		defer close(c)

		random := g.random
		config := &g.config
		counter := 0

		for metricIndex := 0; metricIndex < config.MetricCount; metricIndex++ {
			metricName := fmt.Sprintf("foo_metric_total_%d", metricIndex)

			for targetIndex := 0; targetIndex < config.TargetCount; targetIndex++ {
				ourLabels := []labels.Label{
					{
						Name:  "__name__",
						Value: metricName,
					},
					{
						Name:  "target",
						Value: fmt.Sprintf("target_%d", targetIndex),
					},
				}

				value := float64(random.Intn(1000))

				c <- &valAdapter{v: value, l: ourLabels}
				counter++
			}
		}
	}()

	return c
}

// valAdapter is a small implementation of Val.
// NOTE: it assumes the labels are already sorted!
type valAdapter struct {
	v float64
	l []labels.Label
}

func (v *valAdapter) Val() float64 {
	return v.v
}

func (v *valAdapter) Labels() labels.Labels {
	// simple cast, assume labels are sorted already
	return labels.Labels(v.l)
}
